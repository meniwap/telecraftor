from __future__ import annotations

import keyword
import re
from dataclasses import dataclass
from pathlib import Path

from .ast import TLConstructor, TLMethod, TLSchema


@dataclass(frozen=True, slots=True)
class GeneratedFiles:
    types_py: Path
    functions_py: Path
    registry_py: Path


_RE_NON_IDENT = re.compile(r"[^0-9a-zA-Z_]+")


def _snake(name: str) -> str:
    name = name.replace(".", "_")
    name = _RE_NON_IDENT.sub("_", name)
    name = re.sub(r"([a-z0-9])([A-Z])", r"\1_\2", name)
    name = re.sub(r"_+", "_", name).strip("_")
    return name.lower()


def _pascal(name: str) -> str:
    s = _snake(name)
    out = "".join(part[:1].upper() + part[1:] for part in s.split("_") if part)
    # Avoid invalid identifiers like `class True(...)` for TL constructors named `true`.
    if keyword.iskeyword(out):
        out = f"TL{out}"
    return out


def _safe_ident(name: str) -> str:
    name = _snake(name)
    if not name:
        name = "field"
    if name[0].isdigit():
        name = f"f_{name}"
    if keyword.iskeyword(name):
        name = f"{name}_"
    return name


def _header() -> str:
    return (
        "# This file is auto-generated. DO NOT EDIT.\n"
        "# Generated by tools/gen_tl.py\n"
        "from __future__ import annotations\n\n"
        "from dataclasses import dataclass\n"
        "from typing import ClassVar\n\n"
    )


def _render_constructor(cls: TLConstructor) -> tuple[str, str]:
    py_name = _pascal(cls.name)
    tl_id = cls.constructor_id if cls.constructor_id is not None else 0
    fields: list[tuple[str, str]] = []
    params_meta: list[tuple[str, str]] = []
    seen: set[str] = set()
    for p in cls.params:
        fname = _safe_ident(p.name)
        if fname in seen:
            # very rare, but guard anyway
            i = 2
            while f"{fname}_{i}" in seen:
                i += 1
            fname = f"{fname}_{i}"
        seen.add(fname)
        fields.append((fname, "object"))
        params_meta.append((fname, p.type_ref.raw))

    lines: list[str] = [f"@dataclass(slots=True)\nclass {py_name}(TLObject):"]
    lines.append(f"    TL_ID: ClassVar[int] = {tl_id}")
    lines.append(f'    TL_NAME: ClassVar[str] = "{cls.name}"')
    lines.append(f"    TL_PARAMS: ClassVar[tuple[tuple[str, str], ...]] = {tuple(params_meta)!r}")
    for fname, ftype in fields:
        lines.append(f"    {fname}: {ftype}")
    if not fields:
        lines.append("    pass")
    lines.append("")
    return py_name, "\n".join(lines)


def _render_method(m: TLMethod) -> tuple[str, str]:
    py_name = _pascal(m.name)
    tl_id = m.constructor_id if m.constructor_id is not None else 0
    fields: list[tuple[str, str]] = []
    params_meta: list[tuple[str, str]] = []
    seen: set[str] = set()
    for p in m.params:
        fname = _safe_ident(p.name)
        if fname in seen:
            i = 2
            while f"{fname}_{i}" in seen:
                i += 1
            fname = f"{fname}_{i}"
        seen.add(fname)
        fields.append((fname, "object"))
        params_meta.append((fname, p.type_ref.raw))

    lines: list[str] = [f"@dataclass(slots=True)\nclass {py_name}(TLRequest):"]
    lines.append(f"    TL_ID: ClassVar[int] = {tl_id}")
    lines.append(f'    TL_NAME: ClassVar[str] = "{m.name}"')
    lines.append(f'    TL_RESULT: ClassVar[str] = "{m.result.raw}"')
    lines.append(f"    TL_PARAMS: ClassVar[tuple[tuple[str, str], ...]] = {tuple(params_meta)!r}")
    for fname, ftype in fields:
        lines.append(f"    {fname}: {ftype}")
    if not fields:
        lines.append("    pass")
    lines.append("")
    return py_name, "\n".join(lines)


def generate(schema: TLSchema, out_dir: Path) -> GeneratedFiles:
    """
    Generate `types.py`, `functions.py`, and `registry.py` under `out_dir`.
    """

    out_dir.mkdir(parents=True, exist_ok=True)
    types_py = out_dir / "types.py"
    functions_py = out_dir / "functions.py"
    registry_py = out_dir / "registry.py"

    # Types
    type_chunks: list[str] = [_header(), "from telecraft.tl.runtime import TLObject\n\n"]
    type_names: list[str] = []
    for c in schema.constructors:
        name, chunk = _render_constructor(c)
        type_names.append(name)
        type_chunks.append(chunk)
    type_chunks.append(f"__all__ = {type_names!r}\n")
    types_py.write_text("".join(type_chunks), encoding="utf-8", newline="\n")

    # Functions
    fn_chunks: list[str] = [_header(), "from telecraft.tl.runtime import TLRequest\n\n"]
    fn_names: list[str] = []
    for m in schema.methods:
        name, chunk = _render_method(m)
        fn_names.append(name)
        fn_chunks.append(chunk)
    fn_chunks.append(f"__all__ = {fn_names!r}\n")
    functions_py.write_text("".join(fn_chunks), encoding="utf-8", newline="\n")

    # Registry (constructor_id -> class)
    reg_lines: list[str] = [
        _header(),
        "from typing import Type\n\n",
        "from .types import *  # noqa: F403\n",
        "from .functions import *  # noqa: F403\n\n",
        "TLObjectType = Type[object]\n\n",
        "CONSTRUCTORS_BY_ID: dict[int, TLObjectType] = {\n",
    ]

    for c in schema.constructors:
        if c.constructor_id is None:
            continue
        reg_lines.append(f"    {c.constructor_id}: {_pascal(c.name)},\n")
    reg_lines.append("}\n\nMETHODS_BY_ID: dict[int, TLObjectType] = {\n")
    for m in schema.methods:
        if m.constructor_id is None:
            continue
        reg_lines.append(f"    {m.constructor_id}: {_pascal(m.name)},\n")
    reg_lines.append("}\n")
    registry_py.write_text("".join(reg_lines), encoding="utf-8", newline="\n")

    return GeneratedFiles(types_py=types_py, functions_py=functions_py, registry_py=registry_py)


